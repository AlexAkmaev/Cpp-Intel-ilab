%require "3.0"
%language "c++"


%defines
%define parser_class_name {ParaCL_Parser}
%define api.value.type variant

%param {yy::ParaCL_Driver* driver}

%skeleton "lalr1.cc"


%code requires
{
    #include <iostream>
    #include <algorithm>
    #include <string>
    #include "nodes.hpp"

    #define SCOPES driver->scopes_


    namespace yy {
        class ParaCL_Driver;
    }
}


%code
{
#include "ParaCL_Driver.hpp"

    namespace yy {
        ParaCL_Parser::token_type yylex
        (ParaCL_Parser::semantic_type* yylval,
        ParaCL_Driver* driver);
    }

}


%token
    WHILE
    IF
    ELSE
    PRINT
    LESS_EQ
    GRT_EQ
    AND
    OR
    NOT_EQUAL
    EQUAL
    ERROR
;

%token<int> NUMBER
%token<std::string> ID
%type<Oper_t*> OPS OP1 OP2 OP PROGRAM
%type<Expr_t*> EXPR EXPR1 EXPR2 EXPR_L TERM VAL


%left OR
%left AND

%left
  EQUAL
  NOT_EQUAL
;

%left
  '<'
  LESS_EQ
  '>'
  GRT_EQ
;

%left '+' '-'
%left '*' '/'



%%

%start PROGRAM;

PROGRAM: OPS                            {
                                            $$ = $1;
                                            $1->Evaluate();
                                            /*$1->print();*/
                                            delete $1;
                                        }
;

OPS:    OP                              { $$ = $1; }
|       OPS OP                          { Block* bl = new Block($1, $2, SCOPES.front()); $$ = bl; std::cout << " " << SCOPES.size() <<" "; }//std::cout << " c:" << bl->names.begin()->first << "\n"; }
;

OP1:    '{' OPS '}'                     { $$ = $2; } //Block* b1 = new Block($2); SCOPES.push_back(b1); }
|       EXPR ';'                        { $$ = new Exprop($1); }
|       ';'                             { $$ = new Exprop(); }
|       PRINT EXPR ';'                  { $$ = new Printop($2); }
|       IF '(' EXPR ')' OP1 ELSE OP1    { Block* b1 = new Block($5, SCOPES.front()), *b2 = new Block($7, SCOPES.front());SCOPES.push_front(b2);  SCOPES.push_front(b1); $$ = new Ifop($3, b1, b2); } //Block* bl = new Block($5, $7); }// std::cout << "BL" << (find(SCOPES.begin(), SCOPES.end(), bl) != SCOPES.end()) << "\n"; }
|       WHILE '(' EXPR ')' OP1          { Block* b = new Block($5, SCOPES.front()); SCOPES.push_front(b); $$ = new Whileop($3, b); }
;

OP2:    IF '(' EXPR ')' OP              { Block* b1 = new Block($5, SCOPES.front()); SCOPES.push_front(b1); $$ = new Ifop($3, b1, new Block()); }//SCOPES.pop_back(); std::cout << " cc:" << SCOPES.size() << "\n"; }
|       IF '(' EXPR ')' OP1 ELSE OP2    { Block* b1 = new Block($5, SCOPES.front()), *b2 = new Block($7, SCOPES.front()); SCOPES.push_front(b2);  SCOPES.push_front(b1); $$ = new Ifop($3, b1, b2); }//SCOPES.pop_back(); }//std::cout << " c:" << SCOPES.size() << "\n"; }
|       WHILE '(' EXPR ')' OP2          { Block* b = new Block($5, SCOPES.front()); SCOPES.push_front(b); $$ = new Whileop($3, b); }
;

OP:     OP1                             { $$ = $1; }
|       OP2                             { $$ = $1; }
;

EXPR:   EXPR_L                          { $$ = $1; }
|       ID '=' EXPR                     {
//                                          Block& scope = driver->find_id($1);
                                          Block* scope = (driver->find_id($1));
                                          $$ = new Assign($1, $3, scope);
//                                          $$ = new Assign($1, $3, &(driver->find_id($1)));
                                        }
|       ID '=' '?'                      {
                                          Block* scope = (driver->find_id($1));
                                          $$ = new Scanfop($1, scope);
//                                          $$ = new Scanfop($1, &(driver->find_id($1)));
                                        }
;

EXPR_L : EXPR1                          { $$ = $1; }
|       EXPR_L OR EXPR1                 { $$ = new Binary_expr("||", $1, $3); }
|       EXPR_L AND EXPR1                { $$ = new Binary_expr("&&", $1, $3); }
;

EXPR1:  EXPR2                           { $$ = $1; }
|       EXPR1 EQUAL EXPR2               { $$ = new Binary_expr("==", $1, $3); }
|       EXPR1 LESS_EQ EXPR2             { $$ = new Binary_expr("<=", $1, $3); }
|       EXPR1 GRT_EQ EXPR2              { $$ = new Binary_expr(">=", $1, $3); }
|       EXPR1 NOT_EQUAL EXPR2           { $$ = new Binary_expr("!=", $1, $3); }
|       EXPR1 '>' EXPR2                 { $$ = new Binary_expr(">", $1, $3); }
|       EXPR1 '<' EXPR2                 { $$ = new Binary_expr("<", $1, $3); }
;

EXPR2:  TERM                            { $$ = $1; }
|       EXPR2 '+' TERM                  { $$ = new Binary_expr("+", $1, $3); }
|       EXPR2 '-' TERM                  { $$ = new Binary_expr("-", $1, $3); }
;

TERM:   VAL                             { $$ = $1; }
|       TERM '*' VAL                    { $$ = new Binary_expr("*", $1, $3); }
|       TERM '/' VAL                    { $$ = new Binary_expr("/", $1, $3); }
;

VAL:    NUMBER                          { $$ = new Number($1); }
|       '-' VAL                         { $$ = new Unary_expr("-", $2); }
|       '!' VAL                         { $$ = new Unary_expr("!", $2); }
|       '(' EXPR ')'                    { $$ = $2; }
|       ID                              {
//                                          Block& scope = driver->find_id($1);
                                          Block* scope = (driver->find_id($1));
                                          $$ = new Value($1, scope);
//                                          $$ = new Value($1, &(driver->find_id($1)));
                                        }
;

%%

namespace yy {

    ParaCL_Parser::token_type yylex(ParaCL_Parser::semantic_type* yylval, //ParaCL_Parser::location_type* yylloc,
                             ParaCL_Driver* driver) {
      return driver->yylex(yylval);
    }

    void ParaCL_Parser::error(const std::string&){}

}
