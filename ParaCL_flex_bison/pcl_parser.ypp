%require "3.0"
%language "c++"


%defines
%define parser_class_name {ParaCL_Parser}
%define api.value.type variant
%define api.location.type {unsigned}

%param {yy::ParaCL_Driver* driver}

%skeleton "lalr1.cc"


%code requires
{
    #include <iostream>
    #include <algorithm>
    #include <string>
    #include "nodes.hpp"

//    #define SCOPES driver->scopes_
    #define CBLOCK driver->cur_block

    namespace yy {
        class ParaCL_Driver;
    }

    #define YYLLOC_DEFAULT(Cur, Rhs, N)  \
    if (N) {                             \
      (Cur)=YYRHSLOC(Rhs,1);             \
    } else {                             \
      (Cur)=YYRHSLOC(Rhs,0);             \
    }

}


%code
{
#include "ParaCL_Driver.hpp"

    namespace yy {
        ParaCL_Parser::token_type yylex
        (ParaCL_Parser::semantic_type* yylval, ParaCL_Parser::location_type* yylloc,
        ParaCL_Driver* driver);
    }

}


%token
    WHILE
    IF
    ELSE
    PRINT
    LESS_EQ
    GRT_EQ
    AND
    OR
    NOT_EQUAL
    EQUAL
    ERROR
;

%token<int> NUMBER
%token<std::string> ID
%type<Oper_t*> OPS OP1 OP2 ifscope OP PROGRAM
%type<Expr_t*> ifexpr EXPR EXPR1 EXPR2 EXPR_L TERM VAL


%left OR
%left AND

%left
  EQUAL
  NOT_EQUAL
;

%left
  '<'
  LESS_EQ
  '>'
  GRT_EQ
;

%left '+' '-'
%left '*' '/'



%%

%start PROGRAM;

PROGRAM: OPS                            {
                                            $$ = $1;
                                            $1->Evaluate();
                                            //$1->print();
                                            delete $1;
                                        }
;
//std::cout << "GGG:" << @1 << "\n";
OPS:    OP                              { CBLOCK->append($1); $$ = CBLOCK; }
|       OPS OP                          {/*$1->print(); std::cout << ($1 != nullptr) << "  ^^^  "; $2->print(); std::cout << "\n|";CBLOCK->append($1); */
                                          CBLOCK->append($2); $$ = CBLOCK; }
//std::cout << " " << SCOPES.size() <<" ";Block* bl = new Block($1, $2, SCOPES.front()); $$ = bl;  }
//|       OPS OP                          { Block* bl = new Block($1, $2); $$ = bl;  }
;
//std::cout << "HHH:" << SCOPES[0]->names.size() <<" ";std::cout << " " << SCOPES.size() <<" ";
OP1:    '{' OPS '}'                     { $$ = $2; }
|       EXPR ';'                        { $$ = new Exprop($1); }
//|       ';'                             { $$ = new Exprop(); }
|       PRINT EXPR ';'                  { $$ = new Printop($2); }
//|       IF '(' EXPR ')' OP1 ELSE OP1    { Block* b1 = new Block($5, SCOPES.front()), *b2 = new Block($7, SCOPES.front()); SCOPES.push_front(b2);  SCOPES.push_front(b1); $$ = new Ifop($3, b1, b2); }
//|       WHILE '(' EXPR ')' OP1          { Block* b = new Block($5, SCOPES.front()); SCOPES.push_front(b); $$ = new Whileop($3, b); }
;

OP2:    ifscope                         {
                                          $$ = $1;
                                          CBLOCK = CBLOCK->prev_block;
                                        }
;

ifscope:    ifexpr OP1              {Block* bl = CBLOCK;
//                                           Block* b1 = new Block($2, SCOPES.front());
//                                           if (SCOPES.size() >= 2) {
//                                             Block*& bpr = SCOPES[1];
//                                             bpr->prev_block = b1;
//                                             SCOPES.insert(next(SCOPES.begin()), b1);
//                                           } else {
//                                             SCOPES.push_back(b1);
//                                           }
@1;//std::cout << "GGG:" << (bl != nullptr) << "\n"; bl->print();
                                           bl->append($2);
                                           $$ = new Ifop($1, bl, new Block(bl->prev_block));
                                        }
//|       IF '(' EXPR ')' OP1 ELSE OP2    { Block* b1 = new Block($5, SCOPES.front()), *b2 = new Block($7, SCOPES.front()); SCOPES.push_front(b2);  SCOPES.push_front(b1); $$ = new Ifop($3, b1, b2); }
//|       WHILE '(' EXPR ')' OP2          { Block* b = new Block($5, SCOPES.front()); SCOPES.push_front(b); $$ = new Whileop($3, b); }
;

OP:     OP1                             { $$ = $1; }
|       OP2                             { $$ = $1; }
;


EXPR:   EXPR_L                          { $$ = $1; }
|       ID '=' EXPR                     {
//                                          if(SCOPES.empty())
//                                            SCOPES.push_back(new Block());
//                                          $$ = new Assign($1, $3, SCOPES.back());
                                          //Block* cur = CBLOCK->find_block($1);
                                          $$ = new Assign($1, $3, CBLOCK);
                                        }
|       ID '=' '?'                      {
//                                          if(SCOPES.empty())
//                                            SCOPES.push_back(new Block());
//                                          $$ = new Scanfop($1, SCOPES.back());
                                          //Block* cur = CBLOCK->find_block($1);
                                          //std::cout << "GGG:" << @3 << "\n";
                                          $$ = new Scanfop($1, CBLOCK);
                                        }
;

EXPR_L : EXPR1                          { $$ = $1; }
|       EXPR_L OR EXPR1                 { $$ = new Binary_expr("||", $1, $3); }
|       EXPR_L AND EXPR1                { $$ = new Binary_expr("&&", $1, $3); }
;

EXPR1:  EXPR2                           { $$ = $1; }
|       EXPR1 EQUAL EXPR2               { $$ = new Binary_expr("==", $1, $3); }
|       EXPR1 LESS_EQ EXPR2             { $$ = new Binary_expr("<=", $1, $3); }
|       EXPR1 GRT_EQ EXPR2              { $$ = new Binary_expr(">=", $1, $3); }
|       EXPR1 NOT_EQUAL EXPR2           { $$ = new Binary_expr("!=", $1, $3); }
|       EXPR1 '>' EXPR2                 { $$ = new Binary_expr(">", $1, $3); }
|       EXPR1 '<' EXPR2                 { $$ = new Binary_expr("<", $1, $3); }
;

EXPR2:  TERM                            { $$ = $1; }
|       EXPR2 '+' TERM                  { $$ = new Binary_expr("+", $1, $3); }
|       EXPR2 '-' TERM                  { $$ = new Binary_expr("-", $1, $3); }
;

TERM:   VAL                             { $$ = $1; }
|       TERM '*' VAL                    { $$ = new Binary_expr("*", $1, $3); }
|       TERM '/' VAL                    { $$ = new Binary_expr("/", $1, $3); }
;

VAL:    NUMBER                          { $$ = new Number($1); }
|       '-' VAL                         { $$ = new Unary_expr("-", $2); }
|       '!' VAL                         { $$ = new Unary_expr("!", $2); }
|       '(' EXPR ')'                    { $$ = $2; }
|       ID                              {
//                                          if(SCOPES.empty())
//                                            SCOPES.push_back(new Block());
//                                          $$ = new Value($1, SCOPES.back());
                                          //Block* cur = CBLOCK->find_block($1);
                                          //std::cout << "NNN:" << @1 << "\n";
                                          $$ = new Value($1, CBLOCK);
                                        }
;

ifexpr: IF '(' EXPR ')'                 {
                                          //std::cout << "NNN:" << @3 << "\n";
                                          CBLOCK = new Block(CBLOCK);
                                          $$ = $3;
                                        }
;

%%

namespace yy {

    ParaCL_Parser::token_type yylex(ParaCL_Parser::semantic_type* yylval, ParaCL_Parser::location_type* yylloc,
                             ParaCL_Driver* driver) {
      return driver->yylex(yylval, yylloc);
    }

    void ParaCL_Parser::error(const location_type&, const std::string&){}

}
