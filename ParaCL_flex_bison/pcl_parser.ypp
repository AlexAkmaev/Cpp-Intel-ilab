%require "3.0"
%language "c++"


%defines
%define parser_class_name {ParaCL_Parser}
%define api.value.type variant

%param {yy::ParaCL_Driver* driver}

%skeleton "lalr1.cc"
%locations


%code requires
{
    #include <iostream>
    #include <vector>
    #include <map>
    #include <string>
    #include <cassert>
    #include "nodes.hpp"

    #define SCOPES driver->scopes_

    namespace yy {
        class ParaCL_Driver;
    }
}


%code
{
#include "ParaCL_Driver.hpp"

    namespace yy {
        ParaCL_Parser::token_type yylex
        (ParaCL_Parser::semantic_type* yylval,
        ParaCL_Driver* driver);
    }

}


%token
    WHILE
    IF
    ELSE
    PRINT
    LESS_EQ
    GRT_EQ
    AND
    OR
    NOT_EQUAL
    EQUAL
    ERROR
;

%token<int> NUMBER
%token<std::string> ID
%type<Oper_t*> OPS OP1 OP2 OP PROGRAM
%type<Expr_t*> EXPR EXPR1 EXPR2 EXPR_L TERM VAL


%left OR
%left AND

%left
  EQUAL
  NOT_EQUAL
;

%left
  '<'
  LESS_EQ
  '>'
  GRT_EQ
;

%left '+' '-'
%left '*' '/'



%%

%start PROGRAM;

PROGRAM: OPS                            {
                                            $$ = $1; $1->Evaluate();
                                            /*$1->print();*/
                                            delete $1;
                                        }
;

OPS:    OP                              { $$ = $1; }
|       OPS OP                          { Block* bl = new Block($1, $2); $$ = bl; SCOPES.push_back(bl); }
;

OP1:    '{' OPS '}'                     { $$ = $2; }
|       EXPR ';'                        { $$ = new Exprop($1); }
|       PRINT EXPR ';'                  { $$ = new Printop($2); }
|       IF '(' EXPR ')' OP1 ELSE OP1    { $$ = new Ifop($3, $5, $7); }
|       WHILE '(' EXPR ')' OP1          { $$ = new Whileop($3, $5); }
;

OP2:    IF '(' EXPR ')' OP              { $$ = new Ifop($3, $5, new Block()); }
|       IF '(' EXPR ')' OP1 ELSE OP2    { $$ = new Ifop($3, $5, $7); }
|       WHILE '(' EXPR ')' OP2          { $$ = new Whileop($3, $5); }
;

OP:     OP1                             { $$ = $1; }
|       OP2                             { $$ = $1; }
;

EXPR:   EXPR_L                          { $$ = $1; }
|       ID '=' EXPR                     {
                                          Block* scope = driver->find_id($1);
                                          //if (scope == SCOPES.back())
                                            //scope->names[$1] = $3->Evaluate();
                                          //scope->names[$1] = 0;
                                          $$ = new Assign($1, $3, scope);
                                        }
|       ID '=' '?'                      {
                                          Block* scope = driver->find_id($1);
//                                          int value = -1;
//                                          std::cin >> value;
                                          $$ = new Scanfop($1, scope);
                                        }
;

EXPR_L : EXPR1                          { $$ = $1; }
|       EXPR_L OR EXPR1                 { $$ = new Binary_expr("||", $1, $3); }
|       EXPR_L AND EXPR1                { $$ = new Binary_expr("&&", $1, $3); }
;

EXPR1:  EXPR2                           { $$ = $1; }
|       EXPR1 EQUAL EXPR2               { $$ = new Binary_expr("==", $1, $3); }
|       EXPR1 LESS_EQ EXPR2             { $$ = new Binary_expr("<=", $1, $3); }
|       EXPR1 GRT_EQ EXPR2              { $$ = new Binary_expr(">=", $1, $3); }
|       EXPR1 NOT_EQUAL EXPR2           { $$ = new Binary_expr("!=", $1, $3); }
|       EXPR1 '>' EXPR2                 { $$ = new Binary_expr(">", $1, $3); }
|       EXPR1 '<' EXPR2                 { $$ = new Binary_expr("<", $1, $3); }
;

EXPR2:  TERM                            { $$ = $1; }
|       EXPR2 '+' TERM                  { $$ = new Binary_expr("+", $1, $3); }
|       EXPR2 '-' TERM                  { $$ = new Binary_expr("-", $1, $3); }
;

TERM:   VAL                             { $$ = $1; }
|       TERM '*' VAL                    { $$ = new Binary_expr("*", $1, $3); }
|       TERM '/' VAL                    { $$ = new Binary_expr("/", $1, $3); }
;

VAL:    NUMBER                          { $$ = new Number($1); }
|       '-' VAL                         { $$ = new Unary_expr("-", $2); }
|       '!' VAL                         { $$ = new Unary_expr("!", $2); }
|       '(' EXPR ')'                    { $$ = $2; }
|       ID                              {
                                          Block* scope = driver->find_id($1);
                                          $$ = new Value($1, scope);
                                        }
;


//OPS:    OP                              { std::cout << " OP "; $$ = $1;}//$$ = $1; }
//|       OPS OP                          { std::cout << " OOPS "; $$ = $1;}//$$ = new Block($1, $2); }
//;
//
//OP1:    '{' OPS '}'                     { std::cout << " {OPS} "; $$ = $2;}//$$ = $2; }
//|       EXPR ';'                        { std::cout << " EX; \n"; $$ = $1;}//$$ = new Exprop($1); }
////|       IF '(' EXPR ')' OP1 ELSE OP1    { $$ = new Ifop($3, $5, $7); }
////|       WHILE '(' EXPR ')' OP1          { $$ = new Whileop($3, $5); }
//;
////
////OP2:    IF '(' EXPR ')' OP              { $$ = new Ifop($3, $5, new Block()); }
////|       IF '(' EXPR ')' OP1 ELSE OP2    { $$ = new Ifop($3, $5, $7); }
////|       WHILE '(' EXPR ')' OP2          { $$ = new Whileop($3, $5); }
////;
//
//OP:     OP1                             { std::cout << " OP "; $$ = $1;}//$$ = $1; }
////|       OP2                             { $$ = $1; }
//;
//
//EXPR:   EXPR1                           {std::cout << " EXPR "; $$ = $1;}// $$ = $1; }
//|       ID '=' EXPR                     {std::cout << " ID=EX "; $$ = $1;}// $$ = $3; }
//
//EXPR1:  EXPR2                           { std::cout << " EXPR1 "; $$ = $1;}//$$ = $1; }
////|       EXPR1 EQUAL EXPR2               { $$ = new Binary_expr("==", $1, $3); }
////|       EXPR1 LESS_EQ EXPR2             { $$ = new Binary_expr("<=", $1, $3); }
////|       EXPR1 GRT_EQ EXPR2              { $$ = new Binary_expr(">=", $1, $3); }
////|       EXPR1 NOT_EQUAL EXPR2           { $$ = new Binary_expr("!=", $1, $3); }
//|       EXPR1 '>' EXPR2                 {std::cout << " EX1>EX2 "; $$ = $1;}//
////                                            TOKENS.push_back({$1, TokenType::Data});
////                                            TOKENS.push_back({"<", TokenType::Compare_Op});
////                                            TOKENS.push_back({$3, TokenType::Data});
////                                            $$ = ($1 + "<" + $3);
////                                        }
//|       EXPR1 '<' EXPR2                 {std::cout << " EX1<EX2 "; $$ = $1;}//
////                                            TOKENS.push_back({$1, TokenType::Data});
////                                            TOKENS.push_back({">", TokenType::Compare_Op});
////                                            TOKENS.push_back({$3, TokenType::Data});
////                                            $$ = ($1 + "<" + $3);
////                                        }
//;
//
//EXPR2:  TERM                            { std::cout << " EXPR2 "; $$ = $1;}//$$ = $1; }
//|       EXPR2 '+' TERM                  {std::cout << " EX2+T "; $$ = $1;}//
////                                            TOKENS.push_back({$1, TokenType::Data});
////                                            TOKENS.push_back({"+", TokenType::Arithmetic_Op});
////                                            TOKENS.push_back({$3, TokenType::Data});
////                                            $$ = ($1 + "+" + $3);
////                                        }
//|       EXPR2 '-' TERM                  {std::cout << " EX2-T "; $$ = $1;}//
////                                            TOKENS.push_back({$1, TokenType::Data});
////                                            TOKENS.push_back({"-", TokenType::Arithmetic_Op});
////                                            TOKENS.push_back({$3, TokenType::Data});
////                                            $$ = ($1 + "-" + $3);
////                                        }
//;
//
//TERM:   VAL                             { std::cout << " TERM "; $$ = $1;}//$$ = $1; }
//|       TERM '*' VAL                    {std::cout << " TM*V "; $$ = $1;}//
////                                            TOKENS.push_back({$1, TokenType::Data});
////                                            TOKENS.push_back({"*", TokenType::Arithmetic_Op});
////                                            TOKENS.push_back({$3, TokenType::Data});
////                                            $$ = ($1 + "/" + $3);
////                                        }
//|       TERM '/' VAL                    {std::cout << " TM/V "; $$ = $1;}//
////                                            TOKENS.push_back({$1, TokenType::Data});
////                                            TOKENS.push_back({"/", TokenType::Arithmetic_Op});
////                                            TOKENS.push_back({$3, TokenType::Data});
////                                            $$ = ($1 + "/" + $3);
////                                        }
//;
//
//VAL:    NUMBER                          { std::cout << " NUM ";  $$ = $1;}//TOKENS.push_back({$1, TokenType::Data}); $$ = $1; }
//|       '-' VAL                         { std::cout << " -VAL "; $$ = $2;}//std::string s = "-" + $2; TOKENS.push_back({s, TokenType::Data}); $$ = s; }
//|       '!' VAL                         { std::cout << " !VAL "; $$ = $2;}//std::string s = "!" + $2; TOKENS.push_back({s, TokenType::Data}); $$ = s; }
//|       '(' EXPR ')'                    { std::cout << " (EXPR) "; $$ = $2;}//$$ = $2; }
//|       ID                              { std::cout << " ID "; $$ = $1;}//TOKENS.push_back({$1, TokenType::VarName}); $$ = $1; }
//;


//%token<int> NUMBER
//%token<std::string> ID
//%nterm <int> VAL
//%nterm <int> TERM
//%nterm <int> EXPR2
//%nterm <int> EXPR1
//%nterm <int> EXPR_L
//%nterm <int> EXPR
//
//%nterm <std::vector<int>> OPS OP1 OP2 OP program
//
//
//%left OR
//%left AND
//
//%left
//  EQUAL
//  NOT_EQUAL
//;
//
//%left
//  '<'
//  LESS_EQ
//  '>'
//  GRT_EQ
//;
//
//%left '+' '-'
//%left '*' '/'
//
//
//%%
//
//%start program;
//
//program: OPS    { $$ = $1; }
//;
//
//OPS:    OP      { $$ = $1; /*std::cout << "PP:" << $$[0] << " ";*/ }
//|       OPS OP  { $1.insert($1.end(), $2.begin(), $2.end()); $$ = $1; /*std::cout << "PP:" << $$.size() << " "; */}
//;
//
//OP1:    '{' OPS '}'         { $$ = $2; }
//|       EXPR ';'            { std::vector<int> v; v.push_back($1); /*std::cout << "EE:" << v[0] << " ";*/ $$ = v; }
//|       PRINT EXPR ';'      { std::cout << $2; std::vector<int> v; $$ = v; }
//|       IF '(' EXPR ')' OP1 ELSE OP1  { if($3) {$$.insert($$.end(), $5.begin(), $5.end());} else {$$.insert($$.end(), $7.begin(), $7.end());} }
//|       WHILE '(' EXPR ')' OP1  { std::cout << "FF:" << " ";while($3) {$$.insert( $$.end(), $5.begin(), $5.end());}}
////;
//|       ';'                 { std::vector<int> v; $$ = v;}
//;
////
//OP2:    IF '(' EXPR ')' OP            {  std::cout << "V:"<< $3 << " ";if($3) {$$.insert( $$.end(), $5.begin(), $5.end());}}
//|       IF '(' EXPR ')' OP1 ELSE OP2  { if($3) {$$.insert($$.end(), $5.begin(), $5.end());} else {$$.insert($$.end(), $7.begin(), $7.end());} }
//|       WHILE '(' EXPR ')' OP2   { std::cout << "KK:" << " ";while($3) {$$.insert( $$.end(), $5.begin(), $5.end());}}
//;
////
//OP:  OP1  { $$ = $1; /*std::cout << "VV:" << $$[0] << " "; */}
//|    OP2  { $$ = $1; }
//;
////OP:     OP1;
//
//EXPR:   EXPR_L                  { $$ = $1; }
//|       ID '=' EXPR             { NAMES[$1] = $3; $$ = $3; }
//|       ID '=' '?'              {
//        int data;
//        std::cin >> data;
//        NAMES[$1] = data;
//        $$ = data;
//    }
//;
//
//EXPR_L : EXPR1                  { $$ = $1; }
//|       EXPR_L OR EXPR1         { $$ = ($1 || $3); }
//|       EXPR_L AND EXPR1        { $$ = ($1 && $3); }
//;
//
//EXPR1:  EXPR2                   { $$ = $1; }
//|       EXPR1 EQUAL EXPR2       { $$ = ($1 == $3); }
//|       EXPR1 LESS_EQ EXPR2     { $$ = ($1 <= $3); }
//|       EXPR1 GRT_EQ EXPR2      { $$ = ($1 >= $3); }
//|       EXPR1 NOT_EQUAL EXPR2   { $$ = ($1 != $3); }
//|       EXPR1 '>' EXPR2         { $$ = ($1 > $3); }
//|       EXPR1 '<' EXPR2         { $$ = ($1 < $3); }
//;
//
//EXPR2: TERM             { $$ = $1; }
//|       EXPR2 '+' TERM  { $$ = $1 + $3; }
//|       EXPR2 '-' TERM  { $$ = $1 - $3; }
//;
//
//TERM:   VAL             { $$ = $1; }
//|       TERM '*' VAL    { $$ = $1 * $3; }
//|       TERM '/' VAL    { $$ = $1 / $3; }
//;
//
//VAL:    NUMBER          { $$ = $1; }
//|       '-' VAL         { $$ = -$2; }
//|       '!' VAL         { $$ = !$2; }
//|       '(' EXPR ')'    { $$ = $2; }
//|       ID              { $$ = NAMES[$1]; }
//;
//
//
%%

namespace yy {

    ParaCL_Parser::token_type yylex(ParaCL_Parser::semantic_type* yylval,
                             ParaCL_Driver* driver) {
      return driver->yylex(yylval);
    }

    void ParaCL_Parser::error(const std::string&){}

}






